>题目：求二叉树中两个结点的第一个公共父亲结点

###分析
如果二叉树是**二叉搜索树**，那么第一个公共父亲结点必然是第一个大于两个结点中小的那个，小于两个结点中大的那个。遍历之后选择即可求解。

如果二叉树**有指向父亲结点的指针**，那么求二叉树中两个结点的第一个公共父亲结点，其实就是求两个链表的第一个交点。

如果二叉树是**普通的二叉树**，那么求两个结点的第一个公共父亲结点，传统思路就是先求从根结点到这两个结点的路径，然后再求两个路径的最后一个公共结点，也就是两个结点的第一个公共父亲结点。至于求根结点分别到两个结点的路径，可以参考笔记[二叉树中和为n的路径](quiver:///notes/4196948F-A8A6-481D-AA8B-7CF0EE8972D2)中的解法。

代码如下：

```java
/**
 * @Title: getPath
 * @Description: 结点路径入口函数
 * @param root
 * @param node
 * @return
 * @return: ArrayList<BinaryTree>
 */
public ArrayList<BinaryTree> getPath(BinaryTree root, BinaryTree node) {
	if (root == null) {
		return null;
	}
	// 容器
	ArrayList<BinaryTree> nodeList = new ArrayList<BinaryTree>();
	return getPath(root, node, nodeList);
}

/**
 * @Title: getPath
 * @Description: 得到到某一结点的路径
 * @param root
 * @param node
 * @param nodeList
 */
public ArrayList<BinaryTree> getPath(BinaryTree root, BinaryTree node, ArrayList<BinaryTree> nodeList) {
	ArrayList<BinaryTree> resultList = null;
	boolean found = true;
	if (root.value == node.value) {
		nodeList.add(node);
		resultList = nodeList;
		found = false;
	}
	// 递归实现
	if (found) {
		nodeList.add(root);
		if (root.lChild != null) {
			resultList = getPath(root.lChild, node, nodeList);
			// 找到了就直接返回结果
			if (resultList != null) {
				return resultList;
			}
		}
		if (root.rChild != null) {
			resultList = getPath(root.rChild, node, nodeList);
			// 找到了就直接返回结果
			if (resultList != null) {
				return resultList;
			}
		}
		nodeList.remove(nodeList.size() - 1);
	}
	// 没有找到返回null
	return resultList;
}

/**
 * @Title: getLastCommonNode
 * @Description: 得到list1和list2的最后一个公共结点
 * @param list1
 * @param list2
 * @return
 * @return: BinaryTree
 */
public BinaryTree getLastCommonNode(ArrayList<BinaryTree> list1, ArrayList<BinaryTree> list2) {
	BinaryTree result = null;
	boolean mark = true;
	int index = 0;
	while (mark) {
		if (list1.get(index) == list2.get(index)) {
			result = list1.get(index);
			index++;
		} else {
			mark = false;
		}
	}
	return result;
}

/**
 * @Title: getFirstFather
 * @Description: 入口函数，得到第一个公共结点
 * @param root
 * @param node1
 * @param node2
 * @return
 * @return: BinaryTree
 */
public BinaryTree getFirstFather(BinaryTree root, BinaryTree node1, BinaryTree node2) {
	if (root == null || node1 == null || node2 == null) {
		return null;
	}
	// 得到路径
	ArrayList<BinaryTree> list1 = getPath(root, node1);
	ArrayList<BinaryTree> list2 = getPath(root, node2);
	// 返回路径的最后一个公共结点
	return getLastCommonNode(list1, list2);
}
```